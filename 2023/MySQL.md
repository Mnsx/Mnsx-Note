# MySQL基础知识

## MySQL常见命令

* 查看数据库版本

  `mysql --version`: 用于在未登录情况下，查看本机mysql版本

  `select version()`: 登录情况下，查看连接的库的版本

* 显示所有的库

  `show databases`

* 进入指定的库

  `use 库名`

* 显示当前库的所有表

  `show tables`

* 查看其它库中的所有表

  `show tables from 库名`

* 查看表的创建语句

  `show create table 表名`

* 查看表的结构

  `desc 表名`

## MySQL语法规范

1. 不区分大小写，但规范关键字大写，表名、列名小写
2. 每天命令规范用英文分号结尾
3. 每条命令根据需要，可以进行缩进或换行
4. 注释
   * 单行注释：#注释文字
   * 单行注释：-- 注释文字
   * 多行注释：/* 注释文字 */

## SQL的语句分类

* DQL（Data Query Language）：数据查询语言
* DML（Data Manipulate Language）：数据操作语言
* DDL（Data Define Language）：数据定义语言
* TCL（Transaction Control Language）：事务控制语言

# 详解MySQL数据类型

## MySQL的数据类型

* 整数类型：bit、bool、tinyint、smallint、mediumint、int、bigint
* 浮点数类型：float、double、decimal
* 字符串类型：char、varchar、tinyblob、blob、mediumblob、longblob、tinytext、text、mediumtext、longtext
* 日期类型：Date、DateTime、TimeStamp、Time、Year
* 其他数据类型：...

## 整数类型

| 类型      | 字节数 | 有符号范围        | 无符号范围    |
| --------- | ------ | ----------------- | ------------- |
| tinyint   | 1      | [-2^7, 2^7 - 1]   | [0, 2^8 - 1]  |
| smallint  | 2      | [-2^15, 2^15 - 1] | [0, 2^16 - 1] |
| mediumint | 3      | [-2^23, 2^23 - 1] | [0, 2^24 - 1] |
| int       | 4      | [-2^31, 2^31 - 1] | [0, 2^32 - 1] |
| bigint    | 8      | [-2^63, 2^63 - 1] | [0, 2^64 - 1] |

> **类型(N)说明**：
>
> * 无论N等于多少，int永远占4字节
> * **N表示的是显示宽度，不足的用0补足，超过的无视长度而直接显示整个数字，但这要给整型设置了unsigned zerofill才有效**
> * int(N)中的N可以省略，省略的时候，宽度为对应类型无符号最大值的十进制

## 浮点类型

| 类型    | 字节大小                                        | 范围（有符号）                                      | 范围（无符号）               | 用途           |
| ------- | ----------------------------------------------- | --------------------------------------------------- | ---------------------------- | -------------- |
| float   | 4                                               | [-3.402823466E+38, 3.402823466351E+38]              | [0, 3.402823466E+38]         | 单精度浮点数值 |
| double  | 8                                               | [-1.7976931348623157E+308, 1.7976931348623157E+308] | [0, 1.7976931348623157E+308) | 双精度浮点数值 |
| decimal | 对于DECIMAL(M, D)， 如果M > D，则为M+2，否则D+2 | 依赖于M和D的值                                      | 依赖于M和D的值               | 小数值         |

浮点型和顶点型可以用类型名称 后加(M, D)来表示，M表示该值的总共长度，D表示小数点后面的长度，M和D成为精度和标度

float和double在不指定精度的情况下，默认会按照实际的精度来显示，而DECIMAL在不指定精度时，默认是(10, 0)

## 日期类型

| 类型      | 字节大小 | 范围                                           | 格式                | 用途             |
| --------- | -------- | ---------------------------------------------- | ------------------- | ---------------- |
| DATE      | 3        | 1000-01-01/9999-12-31                          | YYYY-MM-DD          | 日期值           |
| TIME      | 3        | -839:59:59/838:59:59                           | HH:MM:SS            | 时间值或持续时间 |
| YEAR      | 1        | 1901/2155                                      | YYYY                | 年份值           |
| DATETIME  | 8        | 1000-01-01 00:00:00/9999-12-31 23:59:59        | YYYY-MM-DD HH:MM:SS | 混合日期和时间值 |
| TIMESTAMP | 4        | 1970-01-01 00:00:00/北京时间2038-1-19 11:14:07 | YYYYMMMDDHHMMSS     | 时间戳           |

## 字符串类型

| 类型       | 存储所需字节 | 说明                          |
| ---------- | ------------ | ----------------------------- |
| char       | m            | 定产字符串                    |
| varchar    | m            | 0-65535字节                   |
| tinyblob   | L+1          | 不超过255个字节的二进制字符串 |
| blob       | L+2          | 二进制形式的长文本数据        |
| mediumblob | L+3          | 二进制形式的中等长度文本数据  |
| longblob   | L+4          | 二进制形式的极大文本数据      |
| tinytext   | L+1          | 短文本字符串                  |
| text       | L+2          | 长文本数据                    |
| mediumtext | L+3          | 中等长度文本数据              |
| longtext   | L+4          | 极长文本数据                  |

char类型占用固定长度，如果存放的数据为固定长度的建议使用char类型

表格中的L表示存储的数据本身占用的字节，L以外所需的额外字节为存放该值的长度所需的字节数

MySQL通过存储值的内容及其长度来处理可变长的值，这些额外的字节都是无符号整数

# MySQL管理功能

## MySQL权限工作原理

mysql为了安全性考虑，采用主机名+用户名来判断一个用户的身份，，当一个用户对mysql发送指令的时候，mysql就是通过用户名和注解来判定用户的权限

MySQL权限验证分为两个阶段：

1. 阶段1：连接数据库，此时mysql会根据用户名和来源判断是否有权限连接
2. 阶段2：对MySQL服务器发起请求操作，此时mysql会判断是否有权限操作这些指令

## 权限生效时间

用户及权限信息放在库名为mysql的库中，mysql启动时，这些内容被读进内存并且从此时生效，所以如果通过直接操作这些表来修改用户及权限信息，需要重启mysql或者执行`flush privileges`才能生效

用户登录之后，mysql会和当前用户之间创建一个连接，此时用户相关的权限信息都保存在这个连接中，存放在内存中，如果有其他地方修改了当前用户的权限，这些变更的权限会在下一次登陆时才会生效

## 常见管理功能

### 查看mysql中所有用户

用户信息在mysql.user表中

```sql
use mysql;
select user, host from user;
```

### 创建用户

```sql
create user 用户名[@主机名] [identified by '密码'];
```

1. 主机名默认为%，表示这个用户可以从任何主机连接mysql服务器
2. 密码可以省略，表示无密码登录

### 修改密码

* 通过管理员修改密码

  ```sql
  SET PASSWORD FOR '用户名'@'主机' = PASSWORD('密码');
  ```

* 通过修改mysql.user表修改密码

  ```sql
  use mysql;
  update user set authentication_string = password('321') where user = 'test1' and host = '%';
  flush privileges;
  ```

**注意**

通过表方式修改之后，需要通过执行`flush privileges`，才能对用户生效

### 给用户授权

创建用户之后，需要给用户授权

```sql
grant privileges ON database.table TO 'username'[@'host'] [with grant option]
```

**grant命令说明**：

* priveleges（权限列表），可以是all，表示所有权限，也可以是 select、update等权限， 多个权限之间用逗号分开
* ON用来表示指定权限针对那些库和表，格式为数据库.表名，点号前面用来指定数据库名，点号后用来指定表名，`.`表示所有地方
* WITH GRANT OPTION这个选项表示用户可以将自己拥有的权限授予给别人

### 查看用户有哪些权限

```sql
show grants for '用户名'[@'主机']
```

主机可以省略，默认为%

```sql
show grants;
```

查看当前用户的权限

### 撤销用户的权限

```sql
revoke privileges ON database.table FROM '用户名'[@'主机'];
```

### 删除用户

* 方式一

  ```sql
  drop user '用户名'[@‘主机’]
  ```

  drop方式删除用户之后，用户下次登录就会生效

* 方式二

  通过删除mysql.user表数据的方式删除

  ```sql
  delete from user where user='用户名' and host='主机';
  flush privileges;
  ```

## 授权原则说明

* 只授予能满足需要的最小权限，防止用户干坏事，

* 创建用户的时候限制用户的登录主机，一般是限制成指定IP或者内网IP段

* 初始化数据库的时候删除没有密码的用户，安装完数据库的时候会自动创建一些用户，这些用户默认没有密码

* 为每个用户设置满足密码复杂度的密码

* 定期清理不需要的用户，回收权限或者删除用户

# MySQL基础架构

![MySQL基础架构](Picture\MySQL\MySQL基础架构.png)

* 连接器：身份认证和权限相关
* 查询缓存：执行查询语句的时候，会先查询缓存（MySQL8.0后移除）
* 分析器：没有命中缓存的时候，SQL语句就会经过分析器，提取出关键字，分析SQL语句语义，再检查该SQL语句是否有语法错误
* 优化器：按照MySQL认为最优的方案去执行
* 执行器：执行语句，然后从存储引擎返回数据，执行语句之前判断是否有权限，如果没有权限的话，就会报错
* 插件式存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持多种存储引擎

# MySQL存储引擎

## MyISAM和InnoDB有什么区别

1. **是否支持行级锁**

   MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁

2. **是否支持事务**

   MyISAM不提供事务支持，InnoDB支持事务

3. **是否支持外键**

   MyISAM不支持，而InnoDB支持

   外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗，因此，通常情况下，不建议在实际生产中使用外键的

4. **是否支持数据库异常崩溃后的安全恢复**

   MyISAM不支持，而InnoDB支持

   使用InnoDB的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态，**这个恢复的过程依赖于`redo log`**

5. **是否支持MVCC**

   MyISAM不支持，而InnoDB支持

   MVCC可以看作是行级锁的一个升级，可以有效减少加锁的操作，提高性能

6. **索引实现不一样**

   虽然MyISAM和InnoDB引擎都是使用B+Tree作为索引结构，但是两者的实现方式不一样

   InnoDB引擎中，其数据文件本身就是索引文件，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录

   MyISAM，索引文件和数据文件是分离的

7. **性能有差别**

   InnoDB的性能比MyISAM更强大，不管是在读写混合模式下还是只读模式下，随着CPU核数的增加，InnoDB的读写能力呈线性增长，MyISAM因为读写不能并发，它的处理能力跟核数没关系

> **总结**
>
> * InnoDB支持行级别的锁粒度，MyISAM不支持，只支持表级别的锁粒度
> * MyISAM不提供事务支持，InnoDB提供事务支持，实现了SQL标准定义了四个隔离级别
> * MyISAM不支持外键，而InnoDB支持
> * MyISAM不支持MVCC，而InnoDB支持
> * 虽然MyISAM引擎和InnoDB引擎都是使用B+Tree作为索引结构，但是两者实现方式不太一样
> * MyISAM不支持数据库异常崩溃后的安全恢复，而InnoDB支持
> * InnoDB的性能比MyISAM更强大

## InnoDB存储引擎对MVCC的实现

### 一致性非锁定读和锁定读

* 一致性非锁定读

  对于一致性非锁定读的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号+1或者更新时间戳。查询时，将当前可见的版本号和对应记录的版本号进行比对，如果版本小于可见版本，那么表示该记录可见

  在InnoDB存储引擎中，MVCC就是对非锁定读的实现，如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会去等待行上锁的释放，相反回去读一个快照数据（快照读）

* 锁定读

  * `SELECT ... LOCK IN SHARE MODE`
  * `SELECT ... FOR UDPATE`
  * `INSERT`、`UPDATE`、`DELETE`操作

  都是属于锁定读（LOCKING Reads）

  在锁定读下，读取的是数据的最新版本，这种读加S锁，其他事务也可以加S锁，如果加Xs锁，如果加X锁就会被阻塞

  **InnoDB在实现REPEATABLE-READ是，如果执行的是当前读，则会对读取的记录使用Next-Key Lock，来防止其他事务在间隙间插入数据**

  一致性非锁定读，根据Read View判断数据可见性，Read View在第一次查询时生成



# MySQL事务

## ACID特性

* **原子性**：事务是最小的执行单位，不允许分割，事务的原子性确保动作要么完全完成，要么完全不起作用
* **一致性**：执行事务前后，数据保持一致
* **隔离性**：并发访问数据库时，一个用户的事务不被其他事务干扰，各并发事务之间数据库时独立的
* **持久性**：一个事务被提交之后，它对数据库中的数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响

**只有保证了事务的持久性、原子性、隔离性之后，一致性才能的大保障。A、I、D是手段，C是目的**

## 并发事务相关问题

### 脏读

一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交，这是另一个数据读取的还是这个未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，第二个事务读取到的就是脏数据

### 丢失修改

在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据，这样第一个事务内的修改结果就被丢失了，因此成为丢失修改

### 不可重复读

指在一个事务内多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该数据，那么第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两个读取的数据可能不太一样，这就发生了在一个事务内两次读到的数据是不一样的

### 幻读

幻读和不可重复读类似，它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时，在随后的查询中，第一个事务就会发生了一些原本不存在的记录

## 不可重复读和幻读有什么区别

* 不可重复读的重点是内容修改或者记录减少
* 幻读的重点在于记录新增

幻读其实可以看做是不可重复读的一种特殊情况，单独把区分幻读的原因主要解决幻读和不可重复读的方案不一样

## 并发事务的控制方式

MySQL中并发事务的控制方式无非就两种：**锁**和**MVCC**

锁可以看作是悲观控制的模式，多版本并发控制（MVCC）可以看作是乐观控制的模式

**锁**控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL中主要是通过**读写锁**来实现并发控制

* 共享锁（S锁）：读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）
* 排他锁（X锁）：写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取，如果一个记录已经被加了排他锁，那其他事务不能再对这套记录加任何类型的锁（锁不兼容）

读写锁可以做到读读并行，但是无法做到写读、写写并行

根据锁粒度不同，又被分为表级锁和行级锁

无论是表级锁还是行级锁，都存在共享锁和排他锁

MVCC是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的

MVCC在MySQL中实现所以来的手段主要是**隐藏字段、read view、undo log**

* undo log：undo log用于记录某行数据的多个版本数据
* read view和隐藏字段：用来判断当前版本数据的可见性

## SQL标准定义的事务隔离级别

* **READ-UNCOMMITTED（读取未提交）**：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读
* **READ-COMMITTED（读取已提交）**：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
* **REPEATABLE-READ（可重复读）**：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但是幻读仍有可能发生
* **SERIALIZABLE（可串行化）**：最高的隔离级别，完全服从ACID的隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，该级别可以防止脏读、不可重复读以及幻读

## MySQL的隔离级别的实现方式

MySQL的隔离级别基于锁和MVCC机制共同实现的

SERIALIZABLE隔离级别是通过锁来实现的，READ-COMMITTED和REPEATABLE-READ隔离级别是基于MVCC实现的，不过，SERILIZABLE之外的其他隔离级别可能也需要用到锁机制

## MySQL的默认隔离级别

MySQL InnoDB存储引擎的默认支持的隔离级别是**REPEATABLE-READ（可重读）**，我们可以通过`SELECT @@tx_isolation;`，MySQL8.0修改命令为`SELECT @@transaction_isolation`

## MySQL事务隔离级别详解

### 事务隔离级别

* READ-UNCOMMITTED（**读取未提交**）：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读
* READ-COMMITTED（**读取已提交**）：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
* REPEATABLE-READ（**可重复读**）：对同一字段的多次读取结果都是一致的，除非数据是被本身事务所修改，可以阻止脏读和不可重复读，但是幻读仍有可能发生
* SERIALIZABLE（**可串行化**）：最高的隔离级别，完全服从ACID的隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是，该级别可以防止脏读、不可重复读以及幻读

MySQL默认支持REPEATABLE-READ，可以通过`SELECT @@tx_isolation`，8.0后改为`SELECT @@transaction_isolation`

**InnoDB中可重复读可以解决幻读问题**

* **快照读**：由MVCC机制保证不出现幻读
* **当前读**：使用Next-Key Lock进行加锁来保证不出现幻读，Next-Key Lock是行锁和间隙锁的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁

### 解决幻读的方法

* 将事务隔离级别设置为SERILIZABLE
* 在可重复读的事务级别下，将需要操作的表加上表锁
* 在可重复读的事务级别下，将需要操作的表加上Next-Key Lock

# MySQL锁

## 表级锁和行级锁区别

* 表级锁：MySQL中锁定粒度最大的一种锁，是针对索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗非常小，枷锁快，不会出现死锁，不过触发锁冲突的概率最高，高并发场景下效率极低，表级锁和存储引擎无关
* 行级锁：MySQL中锁定力度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁，行级锁能大大减少数据库操作的冲突，其加锁力度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁，行级锁和存储引擎有关，是在存储引擎层面实现的

> InnoDB的行锁是针对索引字段加的锁，表级锁是针对非索引字段家的锁，当执行UPDATE、DELETE时，如果WHERE条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行数据进行加锁

## InnoDB中的行锁

* 记录锁：属于当个行记录上的锁
* 间隙锁：锁定一个范围，不包括记录本身
* 临键锁：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题，**记录锁只能锁住已经存在的记录，为了避免插入新数据，需要依赖间隙锁**

在InnoDB默认的隔离级别REPEATABLE-READ下，行锁默认使用的时Next-Key Lock。但是，如果操作索引是唯一索引或主键，InnoDB会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身而不是范围

## 共享锁和排他锁

不论是表级锁还是行级锁，都存在共享锁（S锁）和排他锁（X锁）

* 共享锁：读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取
* 排他锁：写锁/独占锁，事务在修改记录的时候获取排他锁，不允许其他事务同时获取

由于MVCC的存在，对于一般的SELECT语句，InnoDB不会加任何锁，不过，可以通过语句显示添加共享锁或排他锁

```sql
# 共享锁
SELECT ... LOCK IN SHARE MODE;
# 排他锁
SELECT ... FOR UPDATE;
```

## 意向锁作用

如果需要用到表锁的时候，如何判断表中的记录没有行锁，遍历性能太差，意向锁可以快速判断是否可以对某个表使用表锁

意向锁是表级锁

* 意向共享锁：事务有意向对表中的某些记录加共享锁，加共享锁前必须先获取该表的IS锁
* 意向排他锁：事务有意向对表中的某些记录加排他锁，加排他锁之前必须先取得该表的IX锁

**意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InnoDB会先获取该数据行所在数据表的对应意向锁**

意向锁之间是兼容的

意向锁和共享锁和排他锁互斥（这里指的是表级别的）（s和IS兼容）

## 当前读和快照读

**快照读**（一致性非锁定读）就是单纯的SELECT语句，不包括手动枷锁的语句

快照即记录的历史版本，每行记录可能存在多个历史版本

快照读的情况下，如果读取的记录正在执行UPDATE/DELETE操作，读取操作不会因此去等待记录上X锁的释放，而是会去读取行的一个快照

只有事务隔离级别在RC和RR下，InnoDB才会使用一致性非锁定读

* 在RC级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据
* 在RR级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本

快照读比较适合对于数据一致性要求不是特别高且追求极致性能的场景

**当前读**（一致性锁定读）就是给行记录加X锁或者S锁

# MySQL性能优化

## MySQL存储IP地址

可以将IP地址转换成整型数据存储，性能更好，占用空间更小

* INET_ATON()：把IP转换成无符号整型（4-8位）
* INET_NTOA()：将无符号整型转换成IP地址

## 分析SQL性能

使用`EXPLAIN`命令来分析SQL的执行计划，执行计划是指一条SQL语句在经过MySQL查询优化器的优化后，具体的执行方式

| 列名          | 含义                                         |
| ------------- | -------------------------------------------- |
| id            | SELECT查询的序列标识符                       |
| select_type   | SELECT关键字对应的查询类型                   |
| table         | 用到的标明                                   |
| partition     | 匹配的分区，对于未分区的表，值为Null         |
| type          | 表的访问方法                                 |
| possible_keys | 可能用到的索引                               |
| key           | 实际用到的索引                               |
| key_len       | 所选索引的长度                               |
| ref           | 当使用索引等值查询时，与索引作比较的列或常量 |
| rows          | 预计要读取的行数                             |
| filtered      | 按表条件过滤后，留存的记录数的百分比         |
| Extra         | 附加信息                                     |

# MySQL高性能规范建议

## 数据库命名规范

* 所有数据库对象名称必须使用小写字母并用下划线分割
* 所有数据库对象名称禁止使用MySQL保留关键字
* 临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak\_为前缀并以日期为后缀
* 所有存储相同数据的列名和列类型必须一致

## 数据库基本设计规范

* **所有表必须使用InnoDB存储引擎**

  没有特殊要求的情况下，所有表都必须使用InnoDB促成农户引擎

  InnoDB支持事务、支持行级锁、更好的恢复性、高并发下性能更好

* **数据库和表的字符集统一使用UTF8**

  兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储emoji的需求，字符集需采用utf8mb4字符集

* **所有表和字段都需要添加注解**

  使用comment从句添加表和列的备注，从一开始就进行数据字典的维护

* **尽量控制单表数据的大小，建议控制在500万内**

  500万并不是MySQL数据库的限制，过大会造成修改表结构、备份、恢复都有很大的问题

  可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小

* **谨慎使用MySQL分区表**

  分区表在屋梁上表现为多个文件，逻辑上表现为一个表

  谨慎选择分区键，跨分区查询效率可能更低

  采用物理分表的方式管理大数据

* **经常使用的列放在一个表中**

  避免更多的关联操作

* **禁止在表中建立预留字段**

  * 预留字段的命名很难做到见名识义
  * 预留字段无法确认存储的数据类型，所以无法选择合适的类型
  * 对预留字段类型的修改，会对表进行锁定

* **禁止在数据库中存储文件这类大的二进制数据**

  在数据库中存储文件会严重影响数据库性能，消耗过多的存储空间

  文件这类大的二进制数据通常存储于文件服务器，数据库只存储文件地址信息

* **不要被数据库范式所束缚 **

  一般来设计关系数据库时需要满足第三范式，但为了满足第三范式，可能会拆分出很多张表，而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会减低范式的要求，在表中保存一定的冗余信息，也叫反范式

* **禁止在线上做数据库压力测试**

* **禁止从开发环境、测试环境直接连接生产环境数据库**

## 数据库字段设计规范

* **优先选择符合存储需要的最小的数据类型**

  存储字节越小，占用的空间也就越小，性能也就越好

  * **某些字符串可以转换成数字类型存储**

    数字是连续的，性能更好，占用空间更小

  * **对于非负型的数据来说，要优先使用无符号整型来存储**

    无符号相对于有符号可以多出一倍大的存储空间

  * **小数值类型优先使用TINYINT类型**

* **避免使用TEXT、BLOB数据类型**

  最常见的TEXT类型可以存储64k数据

  * **建议把BLOB或者是TEXT分离到单独的扩展表中**

    MySQL内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行，而且对于这种数据，MySQL还是要进行二次查询，会使SQL性能变得很差，但是不是说一定不能使用这样的数据类型

    **如果一定要使用，建议把BLOB或者TEXT分离到导读的扩展表中，查询时一定不要使用`select *`而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询**

  * **TEXT或BLOB类型只能使用前缀索引**

    MySQL对索引长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的

* **避免使用ENUM类型**

  * 修改ENUM值需要使用ALTER语句
  * ENUM类型的ORDER BY操作效率低，需要额外操作
  * ENUM数据类型存在一些限制

* **尽可能把所有列定义为NOT NULL**

  除非有特别的原因使用NULL值，应该总是让字段保持NOT NULL

  * 索引NULL列需要额外的空间保存，所以要占用更多的空间
  * 进行比较和计算时需要对NULL值进行特别处理

* **使用TIMESTAMP（4字节）或DATETIME（8字节）存储时间**

  TIMESTAMP占用4字节和INT相同，但是比INT可读性高

  超出TIMESTAMP取值范围的使用DATETIME类型

  **使用字符类型来存储时间的缺点**

  * 无法使用日期函数进行计算和比较
  * 用字符串存储日期要占用更多的空间

* **同财务相同的金额类数据必须使用DECIMAL类型**

* **单表不要包含过多字段**

  如果一个表包含过多字段的话，可以考虑将其分为多个表，必要时增加中间表进行关联

## 索引设计规范

* **限制每张表上的索引数量，建议单张表索引不超过5个**

  索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至会降低查询效率

  因为MySQL优化器在选择如何优化时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用来查询，就会增加MySQL优化器生成执行计划的时间，同样会降低查询性能

* **禁止使用全文索引**

  全文索引不适用于OLTP场景（线上交易）

* **禁止给表中的每一列都建立单独的索引**

  5.6以后，虽然有了合并索引的优化方案，但是还是远远没有使用一个联合索引的查询方式好

* **每个InnoDB表必须有一个主键**

  InnoDB是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的，每个表都可以有多个索引，但是表的存储顺序只能有一种

  InnoDB是按照主键索引的顺序来组织表的

  * 不要使用更新频繁的列作为主键，不适用多列主键
  * 不要使用UUID，MD5，HASH，字符串列作为主键
  * 主键建议使用自增ID值

* **常见索引列建议**

  * 出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列
  * 包含在ORDER BY、GROUP BY、DISTINCT中的字段
  * 并不要将符合1和2中的字段的列都创建一个索引，通常将1、2中的字段创建联合索引效果更好
  * 多表JOIN的关联列

* **如何选择索引列的顺序**

  创建索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能，索引能过滤出越少的数据，从磁盘中读入的数据也就越少

  * 区分度最高的放在联合索引的最左侧
  * 尽量把字段长度小的放在联合索引的最左侧
  * 使用最平凡的列放在联合索引的左侧

* **避免奖励冗余索引和重复索引**

* **对于频繁的查询优先考虑使用覆盖索引**

  > 覆盖索引：就是包含了所有查询字段的索引

  覆盖索引的好处：

  * **避免InnoDB表进行索引的二次查询**

    InnoDB是以聚集索引的顺序来存储的，对于InnoDB来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取真实所需的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询，减少了IO操作，提升了查询效率

  * **可以把随机IO编程顺序IO来加快查询效率**

    由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少得多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO

## 数据库SQL开发规范

* **优化对性能影响较大的SQL语句**

  要找到最需要优化的SQL语句，要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询MySQL的慢查询日志来发现需要进行优化的SQL语句

* **充分利用表上已经存在的索引**

  避免使用双%作为查询条件，**如果无前置%，只有后置%，是可以用到列上的索引的**

  在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧，使用left join或not exists来优化not int操作，因为not in也通常会使用索引失效

* **禁止使用SELECT *必须使用SELECT <字段列表>查询**

  * SELECT *消耗更多的CPU和IO以及网络带宽资源
  * SELECT *无法使用覆盖索引
  * SELECT <字段列表>可减少表结构变更带来的影响

* **禁止使用不含字段列表的INSERT语句**

* **建议使用预编译语句进行数据库操作**

* **避免数据类型的隐式转换**

  隐式转换会导致索引失效

  ```sql
  select name,phone from customer where id = '111';
  ```

* **避免使用子查询，可以把子查询优化为join操作**

  通过子查询在in子句中，且子查询中的简单SQL（不包含UNION、GROUP BY、ORDER BY、LIMIT从句）时，才可以把子查询转化为关键查询进行优化

  **子查询性能差的原因**

  子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询

* **避免使用JOIN关联太多的表**

  对于MySQL来说，是存在关键缓存的，缓存的大小可以由join_buffer_size参数进行设置

  在MySQL中，对于同一个SQL多关联一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大

  如果程序中大量使用多表关联的擦欧总，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性

  MySQL建议关联表不超过5个

* **减少同数据库的交互次数**

  数据库更适合处理批量操作，合并多个相同的操作在一起，可以提高处理效率

* **对应同一列进行or判断时，使用in代替or**

  in的值不要超过500个，in操作可以更有效的利用索引，or大多数情况下很少能利用到索引

* **禁止使用order by rand()进行随机排序**

  order by rand()会把表中所有符合条件的数据装载到内存中，然后再内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都声称一个随机值，如果满足条件的数据集非常大，就会消耗大量的CPU和IO以及内存资源

* **WHERE从句中禁止对列进行函数转换和计算**

  对列进行函数转换或计算时会导致无法使用索引

* **在明显不会有重复值时使用UNNION ALL而不是UNION**

  * UNION会把两个结果集的所有数据放到临时表中后再进行去重操作
  * UNION ALL不会再对结果集进行去重操作

* **拆分复杂的大SQL为多个小SQL**

  * 大SQL逻辑上比较复杂，需要占用大量CPU进行计算的SQL
  * MySQL中，一个SQL只能使用一个CPU进行计算
  * SQL拆分后可以通过并行来执行来提高处理效率

## 数据库操作行为规范

* **超过100万行的批量写操作，要分批多次进行操作**

  * **大批量操作可能会造成严重的主从延迟**

    主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般需要执行一定长时间，而只有当主库上执行完成后，才会在其他从库中执行，所以会造成主库和从库长时间的延迟情况

  * **binlog日志为row格式时会产生大量的日志**

    大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需的时间也就越长，这也是造成主从延迟的一个原因

  * **避免产生大事务操作**

    大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL性能产生非常大的影响

    特别是长时间的阻塞会占满素有数据库的可用连接，这回使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批

# MySQL索引详解

## MySQL的优缺点

**优点**：

* 使用索引可以大大加快数据的检索速度，这也是创建索引的最主要的原因
* 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性

**缺点**：

* 创建索引和维护索引需要耗费许多时间，当对表中的数据进行增删改查的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率
* 索引需要使用物理文件存储，也会耗费一定空间

**如果数据库的数据量不打，那么使用索引也不一定能带来很大的提升**

## 索引底层数据结构选型

* **Hash表**

  哈希表是键值对的集合，通过键即可快速去除对应的值，因此哈希表可以快速检索数据（接近O(1)）

  由于哈希算法的远古，通过哈希算法，可以通过快速找到key对应的index，找到了index也就可以找到对应的value

  但是哈希算法存在hash冲突，也就是说同一个key最后得到的index相同，通常情况下，我们常用的解决问题时**链地址法**，链地址法就是将哈希冲突数据存放在链表中

  **MySQL没有使用Hash表作为索引的原因**

  主要是因为Hash索引不支持顺序和范围查询，并且每次IO之呢个获取一个数据

* **二叉查找树（BST）**

  二叉查找树是一种基于二叉树的数据结构

  * 左子树所有节点的值均小于根节点的值
  * 右子树所有节点的值均大于根节点的值
  * 左右子树也分别为二叉查找树

  当二叉树是平衡的时候，也就是树的每个节点的左右子树深度相差不超过1的时候，查询时间复杂度为（O(log2(N)），具有比较高的效率，然而，当二叉查找树不平衡的时候，树会退化成线性链表，导致查询效率急剧下降，时间复杂度退化为（O(N)）

  **二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为MySQL底层索引的数据结构**

* **AVL树**

  AVL树是最早发明的自平衡二叉查找树，AVL树的特点是保证任何节点的左右子树高度之差不超过1，因此也被称为高度平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logN)

  AVL树采用了旋转操作来保证平衡，主要有四种旋转操作，LL旋转、RR旋转、LR旋转和RL旋转

  由于AVL树需要频繁进行旋转操作来保持平衡，因此会有较大的计算开销进而降低查询性能，并且在使用AVL树时，每个树节点仅存储一个数据，而每次进行磁盘IO时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么需要进行多次磁盘IO

  **磁盘IO是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如果最大限度地减少磁盘IO操作的次数**

* **红黑树**

  红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态

  * 每个节点非红即黑
  * 根节点总是黑色
  * 每个叶子节点都是黑色的空节点
  * 如果节点是红色的，则它的子节点必须是黑色的
  * 从根节点到叶节点或空子节点的每条路径，必须包含相同数量的黑色节点

  和AVL树不同的是，红黑树并不追求严格的平衡，而是大致的平衡，正因如此，红黑树的查找效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘IO操作才能查询到，红黑树的插入和删除操作效率大大提高，因为红黑树在插入和删除节点时只需进行O(1)次数的旋转和变色操作，即可保持基本平衡状态

* **B树&B+树**

  B树，全称为多路平衡查找树，B+树是B树的一种变体

  目前大部分数据库系统及文件系统都是采用B树或者B+树作为索引结构

  **B树和B+树两者有何异同**

  * B树的所有节点既存放键也存放数据，而B+树只有叶子节点存放key和data，其他节点只存放key
  * B树的叶子节点都是独立的，B+树的叶子节点有一条引用链指向它相邻的叶子节点
  * B树的检索过程相当于对范围内的每个节点的关键字进行二分查找，可能还没有达到叶子节点，检索就结束了，而B+树的检索效率更加稳定，任何查找都是从根节点到叶子节点的过程，叶子节点顺序检索很明显
  * 在B树中进行范围查询时，首先找到要查找的下限，然后对B树进行中序遍历，知道找到查找的上限，而B+树的范围查询，只需要对链表进行遍历即可

## 索引类型总结

**按照底层存储方式角度划分**

* 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB中的主键索引就是聚簇索引
* 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引（辅助索引）就属于非聚簇索引，MyISAM引擎，不管主键还是非主键都是使用非聚簇索引

**按照应用维度划分**

* 主键索引：加速查询+列值唯一+表中只有一个
* 普通索引：加速查询
* 唯一索引：加速查询+列值唯一
* 覆盖索引：一个索引包含所有需要查询的字段值
* 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
* 全文索引：对文本内容进行分词，进行搜索，目前只有CHAR、VARCHAR、TEXT列上可以创建全文索引，一般不会使用，效率较低，通常使用搜索引擎代替

MySQL 8.x中实现的索引

* 隐藏索引：不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用，主键不能被设置为隐藏
* 降序索引
* 函数索引：支持在索引中使用函数或表达式的值，也就是在索引中可以包含函数或表达式

## 主键索引

数据表的主键列使用的就是主键索引

一张数据表只能有一个主键，并且主键不能为null，不能重复

在MySQL的InnoDB的表中，当没有显式的指定表的主键时，InnoDB会自动先检查表中是否有唯一的所有且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则InnoDB将自动创建一个6Byte的自增主键

## 二级索引

**二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据就是主键，也就是说通过二级索引，可以定位主键的位置**

唯一索引、普通索引、前缀索引等索引都属于二级索引

* **唯一索引**：唯一索引也是一种约束，**唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引**，创建唯一索引的目的，大部分时候都是为了该属性的数据的唯一性，而不是为了查询效率
* **普通索引**：**普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL**
* **前缀索引**：前缀索引只适用于字符串类型的数据，前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符
* **全文索引**：全文索引主要为了检索大文本数据中的关机纳兹信息，是目前搜索引擎数据库使用的一种技术

## 聚簇索引和非聚簇索引

### 聚簇索引

**聚簇索引即索引结构和数据一起存放的索引，并不是一种单独的索引类型，InnoDB中主键索引就是聚簇索引**

在MySQL中，InnoDB索引的表的.ibd文件就包含了该表的索引和数据，对于InnoDB索引表来说，该表的索引的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据

**优点**：

* **查询速度非常快**：聚簇索引的查询速度非常快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据，相比于非聚簇索引，聚簇索引少了一次读取数据的IO操作
* **对排序查找和范围查找优化**：聚簇索引对于主键的排序查找和范围查找的速度非常快

**缺点**：

* **依赖于有序的数据**：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据时整型还好，否则类似于字符串或UUID这种长数据，插入或查询的速度比较慢
* **更新代价大**：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且索引的叶子节点还存放着数据，修改代价是比较大的，所以对于主键索引来说，主键一般都是不可修改的

### 非聚簇索引

**非聚簇索引即索引结构和数据分开存放的索引，并不是一种单独的索引类型，二级索引就是非聚簇索引，MySQL的MyISAM引擎，不管是主键还是非主键都是非聚簇索引**

非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再去会查数据

**优点**：

更新代价比聚簇索引小，非聚簇索引的叶子节点不存放数据

**缺点**：

* **依赖于有序的数据**
* **可能会二次查询（回表）**：这是非聚簇索引最大的缺点，当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件中或者表中查询

> **非聚簇索引不一定回表查询**
>
> 用户查找的数据正好就是索引字段，那么就无需回表查询
>
> 如果查询的是主键，也不需要回表，这就是覆盖索引

## 覆盖索引和联合索引

### 覆盖索引

如果一个索引包含所需查询的字段值，称之为覆盖索引

覆盖索引就是把要查询出的列和索引是对应的，不需要做回表操作

**覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据，而无需回表查询**

### 联合索引

使用表中的多个字段创建索引，就是联合索引

## 最左前缀匹配原则

最左前缀匹配原则指的是，在使用联合索引时，MySQL会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在于联合索引中最左侧的字段相匹配的字段，则就使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者再执行过程中遇到范围查询，就会停止

**可以将区分度高的字段放在最左边，也可以过滤更多数据**

## 索引下推

索引下推是5.6版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数

## 正确使用索引的建议

* **选择合适的字段创建索引**

  * 不为NULL的字段
  * 被频繁查询的字段
  * 被作为条件查询的字段
  * 频繁需要排序的自读那
  * 被经常频繁用于连接的字段

* **被频繁更新的字段应该慎重建立索引**

  虽然索引能带来查询上的效率，但是维护索引的成本也是不小的，如果一个字段不被经常查询，反而被经常修改，那么就更不应该再这种字段上建立索引

* **限制每张表上的索引数量**

  建议单张表的索引不超过5个

  索引可以增加查询效率，也会降低插入和更新效率，甚至有些情况下会降低查询效率

  因为MySQL优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用来查询，就会增加MySQL优化器生成执行计划的时间同样会降低查询性能

* **尽可能使用联合索引而不是单例索引**

* **避免创建冗余索引**

* **字符串类型字段建议使用前缀索引替代普通索引**

* **避免索引失效**

  * 使用SELECT \*不会直接导致索引失效，但是它会带来一些其他的性能问题（网络传输和数据的处理的浪费、无法使用覆盖索引）
  * 创建了组合索引，但是查询条件未遵循最左匹配原则
  * 在索引列上进行计算、函数、类型转换等操作
  * 以%开头的LIKE查询
  * 查询条件中使用or，且or的前后条件中有一个列没有索引，设计的索引都不会被使用

* **删除长期未使用的索引**

  MySQL5.7以后可以通过查询sys库中的schema_unuserd_indexes试图来查询那些索引从未被使用过

# MySQL日志

MySQL日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志，其中比较重要的二进制日志bin log（归档日志）和事务日志redo log（重做日志）和undo log（回滚日志）

![MySQL日志](Picture\MySQL\MySQL日志.png)

## redo log

redo log（重做日志）时InnoDB存储引擎独有的，它让MySQL拥有了崩溃恢复能力

MySQL实例挂了或者宕机了，重启时，InnoDB存储引擎会使用redo log恢复数据，保证数据的持久性与完整性

MySQL中数据都是先从Buffer Pool中找，没有命中再去硬盘中加载，减少硬盘IO爱笑，提升性能

> MySQL查询缓存属于Server层，而Buffer Pool处于存储迎请

更新表数据的时候，也是如此，发现Buffer Pool里存在更新的数据，就直接在Buffer Pool中更新

然后会把”在某个数据页上做了什么修改“记录到重做日志缓存中，接着刷盘到redo log文件中

理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机时根据策略来进行的

### 刷盘时机

InnoDB存储引擎为redo log的刷盘策略提供了innodb_flush_log_at_trx_commit参数

* 0：设置为0时，表示每次事务提交时不进行刷盘操作
* 1：设置为1时，表示每次事务提交时都将进行刷盘操作（默认值）
* 2：设置为2时，表示每次事务提交时都只会把redo log buffer内容写入page cache

参数设置默认为1，当事务提交时会调用fsync对redo log进行刷盘

InnoDB存储引擎有一个后台线程，每隔1s，就会把redo log buffer中的内容写到文件系统缓存（page cache），然后嗲用fsync刷盘

出了后台线程每秒一次的轮询操作看，还有一种情况，当redo log buffer占用的空间即将达到innodb_log_buffer_size的一半时，后台线程会主动刷盘

### 日志文件组

硬盘上存储的redo log日志文件不止一个，而是以一个日志文件组的形式出现，每个redo日志文件大小都是一样的

它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写

![日志文件组图解](Picture\MySQL\日志文件组图解.png)

在日志文件组中还有两个重要的属性，分别是write pos、checkpoint

* write pos是当前记录的位置，一边写一边往后移
* checkpoint是当前要擦除的位置，也是往后推移

每次刷盘redo log记录到日志文件组时，write pos位置就会后移更新

每次MySQL加载日志文件组恢复数据时，会清空加载过的redo log记录，并把checkpoint后移更新

write post和checkpoint之间还空着的部分可以用来写入redo log记录

如果write post追上checkpoint，表示日志文件组满了，这时候不能再写入新的redo log记录，MySQL需要停下来，清空一些记录，把checkpoint推进一下

**redo log小结**

**只要把每次修改后的数据页直接刷盘就行了，为什么需要redo log**

实际上，数据页大小是16kb，刷盘比较耗时，没有必要将完整的数据页刷盘

而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能很差

所以用redo log形式记录修改记录，性能会远远超过刷数据页的方式

## bin log

redo log是物理日志，属于InnoDB存储引擎，而bin log是逻辑日志，记录内容是语句的原始逻辑，属于MySQL Server层

不管使用什么存储引擎，只要发生了表数据更新，就会产生bin log日志

可以说MySQL数据库的数据备份、主备、主主、主从都离不开bin log，需要依靠bin log来同步数据，保证数据一致性

### 记录格式

bin log日志有三种格式，可以通过binglog_format参数指定

* statement
* row
* mixed

指定statement，记录的内容是SQL语句原文

同步数据时，会执行记录的SQL语句，但是now()这类的函数会获取当前系统的时间，直接执行会导致与原库的数据不一致

![bin_log_statement](Picture\MySQL\bin_log_statement.png)

为了解决问题，可以指定为row，记录的内容不在时SQL语句，还包括操作的具体数据

![bin_log_row](Picture\MySQL\bin_log_row.png)

row格式记录的内容看不到详细信息，要通过mysqlbinlog工具解析

now()就会变成具体时间，条件后面的@1、@2、@3都是该行数据第一个-第三个字段的原始值

通常情况下指定为row，这样可以为数据库的恢复与同步带来更好的可靠性

但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时更小号IO资源，影响执行速度

所以，可以指定为mixed，记录的内容为两者的混合

MySQL会判断这条SQL语句是否可能引起数据不一致，如果是，就会用row格式，否则使用statement格式

### 写入机制

binlog写入时机非常简单，事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到bin log文件中

因为一个事务的binlog不能被拆开，无论这个事务有多大，也要确保一次性写入，所以系统会给每个线程分配一块内存作为binlog cache

可以通过binlog_cache_size参数控制单个线程binlog cache大小，如果存储内容超过了这个参数，就会暂存到磁盘

![binlog写入机制](Picture\MySQL\binlog写入机制.png)

* **write是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快**
* **fsync才是将数据持久化到磁盘的操作**

write和fsync的时机，可以由参数sync_binlog控制，默认为0

为0时，表示每次提交事务都只write，由系统自行判断什么时候执行fsync

虽然性能得到提升，但是机器宕机，page cache里面的binlog会丢失

为了安全起见，可以设置为1，表示每次执行事务都会执行fsync，就如同redo log日志刷盘流程一样

最后还有一种折中方式，可以设置为N(N > 1)，表示每次提交事务都会write，但是积累N个事务后才fsync

在出现IO瓶颈的场景里，将sync_binlog设置成比较大的值，可以提升性能

同样，如果机器当即，会丢失最近的N个事务的binlog日志

## 两阶段提交

redo log（重做日志）让InnoDB存储引擎拥有了崩溃恢复的能力

bin log（归档日志）保证了MySQL集群架构的数据一致性

在执行更新语句过程，会记录redo log与bin log两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而bin log只有在提交事务时才写入，所以redo log与bin log的写入时机不一样

**案例**

```sql
update T set c = 1 where id = 2
```

执行过程中写完redo log日志后，binlog日志写期间发生了异常

由于binglog没有写完就异常，这时候binlog里面没有对应的修改记录，因此，之后用binlog日志恢复数据时，就会少这一次更新

为了解决两份日志之间的逻辑一致性问题，InnoDB存储引擎使用两阶段提交方案

**将redo log的写拆成两个步骤prepare和commit，这就是两阶段提交**

![两阶段提交](D:\WorkSpace\Mnsx-Note\2023\Picture\MySQL\两阶段提交.png)

使用两阶段提交后，写入binlog时发生异常不会有影响，因为MySQL会根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并没有对应bin log日志，就会回滚该事务

## undo log

想要保证事务的原子性，就需要异常发生时，对已经执行的操作进行回滚，在MySQL中恢复机制就是通过回滚日志实现

并且会不能日志会先于数据持久化到磁盘上，这样保证了即使遇到数据库突然宕机等情况，用户再次启动数据库时，数据库还可以通过查询回滚日志来回滚之前未完成的事务
