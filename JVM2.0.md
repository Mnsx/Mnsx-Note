# JVM和Java体系结构

![image-20221113151419446](D:\WorkSpace\Note\Picture\image-20221113151419446.png)

# 内存概述

## 类加载过程

### Loading

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存上生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

### Linking

* 验证（Verify）
  * 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证加载类的正确性，不会危害虚拟机自身安全
  * 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证
* 准备（Prepare）
  * 为类变量分配内存并且设置该类变量的默认初始值，即零值
  * 这里不包含final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化
  * 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随对象一起分配到Java堆中
* 解析（Resolve）
  * 将常量池内的符号引用转换为直接引用的过程
  * 事实上，解析操作往往伴随着JVM执行完初始化之后再执行
  * 符号引用就是一组符号来秒速所引用的目标，符号引用的字面量形式明确定义再Class文件格式中，直接引用就是直接指向目标的指针、 相对偏移量或一个简介定位到目标的句柄
  * 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等，对应常量池中CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Mehthodref_info等

### Initialization

* 初始化阶段就是执行类构造器方法\<clinit>()的过程
* 此方法不需定义，是javac编译器自动收集类中的所有变量的赋值动作和静态代码块中的语句合并而来
* 构造器方法中指令按语句在源文件中出现的顺序执行
* \<clinit>()不同于类的构造器（关联：构造器是虚拟机视角下的\<init>()）
* 若该类具有父类，JVM会保证子类的\<clinit>()执行前，父类的\<clinit>()已经执行完毕
* 虚拟机必须保证一个类的\<clinit>()方法在多线程下被同步加锁

## 类加载器分类

* JVM支持两种类加载器，分别为引导类加载器和自定义类加载器
* 将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器
* Java的核心类库都是使用引导类加载器进行加载的，无法获取引导类加载器

### 启动类加载器

引导类加载器，Bootstrap ClassLoader

* 使用C/C++语言实现的，嵌套在JVM内部
* 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resoueces.jar或sum.boot.class.path路径下的内容），用来提供JVM自身需要的类
* 并不继承自java.lang.ClassLoader，没有父加载器
* 加载扩展类和应用程序加载器，并指定为他们的父类加载器
* 处于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类

### 扩展类加载器

扩展类加载器，Extension ClassLoader

* Java语言编写，由sun.misc.Launcher$ExtClassLoader实现
* 派生于ClassLoader类
* 父类加载器为启动类加载器
* 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载

### 应用程序类加载器

系统类加载器，AppClassLoader

* java语言编写，由sun.misc.Launcher$AppClassLoader实现
* 派生于ClassLoader类
* 父类加载器为扩展类加载器
* 它负责加载环境变量classpath或系统属性 java.class.path指定路径下的类库
* 该类加载时程序中默认的类加载器，一般来说，java应用的类都是由它加载的
* 通过ClassLoader#getSystemClassLoader()可以获取该类加载器

### 用户自定义类加载器

使用自定义类加载器的原因——

* 隔离加载类
* 修改类加载的方式
* 扩展加载源
* 防止源码泄露

## 获取ClassLoader的途径

![image-20221114123725255](D:\WorkSpace\Note\Picture\image-20221114123725255.png)

## 双亲委派机制

Java虚拟机对class文件采用的时**按需加载**的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，Java虚拟机采用的是**双亲委派模式**，即把请求交由父类处理，它是一种任务委派模式

> 双亲委托模式——
>
> 将类加载请求，委托给父类，如果父类有父类，那么就会一直向上委托，直到没有父类，如果父类无法处理这个类加载，才会由子类进行加载

双亲委派机制的优势——

* 避免类的重复加载
* 保护程序安全，防止核心API被随意篡改

## 沙箱安全机制

自定义Jdk自带的类，会在加载该类时，率先使用引导类加载器加载，而引导类加载器在加载的过程中，会先加载jdk自带的文件，这可以保证对Java核心源代码的保护

# 运行时数据区

### 概述

每个线程：独立包括程序计数器、栈、本地栈

线程间共享：堆、堆外内存（永久代或元空间、代码缓存）

每一个Java程序就相当于一个Runtime程序

### 线程

当一个Java线程准备好执行之后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收

