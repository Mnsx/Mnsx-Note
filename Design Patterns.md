# 设计模式

## 学习资料

[永不磨灭的设计模式](https://blog.csdn.net/ShuSheng0007/article/details/115980889)

## 总结

| 类型    | 模式                          | 描述                                                         |
| ------- | :---------------------------- | ------------------------------------------------------------ |
| 行为型  | 迭代器Iterator                | 提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示 |
| 结构性  | 适配器Adapter                 | 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作 |
| 行为型  | 模板方法Template Method       | 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤 |
| 创建型  | 工厂方法Factory Method        | 定义一个用于创建产品的接口，由子类决定生产什么产品           |
| 创建型  | 单例Singleton                 | 某个类只能生成一个实例，该类提供一个全局访问点供外部获取实例。其拓展是有限多例 |
| 创建型  | 原型Prototype                 | 以某个对象为原型，对其进行复制克隆                           |
| 创建型  | 建造者Builder                 | 将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象 |
| 创建型  | 抽象工厂Abstract Factory      | 提供一个创建产品族的接口，其每一个子类决定生产什么产品       |
| 结构性  | 桥接Bridge                    | 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这个可变维度的耦合度 |
| 行为型  | 策略Strategy                  | 定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户 |
| 结构型  | 组合Composite                 | 将对象组合成树状层次结构，使用户对的那个对象和组合对象具有一致的访问性 |
| 结构型  | 装饰Decorator                 | 动态的给对象增加一些职责，即增加其额外的功能                 |
| 行为型  | 访问者Visitor                 | 在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问 |
| 行为型  | 指责链Chain of Responsibility | 把请求链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合 |
| 结构 型 | 外观Facade                    | 为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易访问 |
| 行为型  | 中介者Mediator                | 定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互不了解 |
| 行为型  | 观察者Observer                | 多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象行为 |
| 行为型  | 备忘录Memento                 | 在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它 |
| 行为型  | 状态State                     | 允许一个对象在其内部状态发生改变时该改变其行为能力           |
| 结构型  | 享元Flyweight                 | 运用共享技术来有效地支持大量细粒度对象的服用                 |
| 结构型  | 代理Proxy                     | 对某对象提供一种代理以控制对该对象的访问。即客户端通过代理简介访问该对象，从而限制、增强或修改对象的一些特性 |
| 行为型  | 命令Command                   | 将一个请求封装为一个对象，便发出请求的责任和执行请求和责任分隔开 |
| 行为型  | 解释器Interpreter             | 提供如何定义语言的文法，以及对语言句子的解释方法，即解释器   |

## [迭代器模式](https://blog.csdn.net/ShuSheng0007/article/details/117903838)

* 使用场景

  在Java开发中，当你要实现自己的容器类时，且要迭代里面的元素时。换句话说，当你要使自己的类支持foreach操作的时候使用此模式

  **但是Java中没有必要自己实现这个模式，因为Java类库默认支持此模式**

## [适配器模式](https://blog.csdn.net/ShuSheng0007/article/details/116161690)

适配器模式还有个别名叫：Wrapper（包装器），顾名思义就是将目标类用一个新类包装一下

* 使用场景

  当需要使用一个现存的类，但它提供的接口与我们系统的接口不兼容，而我们还不能修改它时

  当多个团队独立开发系统的各功能模块，然后组合在一起，但由于某些原因事先不能确定接口时

## [模板方法模式](https://blog.csdn.net/ShuSheng0007/article/details/88832293)

这个设计模式一般在最初写代码的时候基本上是不会预先想到的，都是在后期不断重构的过程中被提炼出来的。

当发现自己的代码中有两个或者多个几乎一毛一样的类，只是有些方法的实现方式不一致的时候，同时使用这些类的地方调用方法顺序都一样时就可以选择使用这个设计模式

## [工厂方法模式](https://blog.csdn.net/ShuSheng0007/article/details/86636494)

在工厂模式中，我们创建对象时不会对客户端暴露创建逻辑，并且是通过一个共同的接口来指向新创建的对象，然后通过对工厂类指定不同的生成方式来生成不同的对象

1. 你不想直接new这个类对象，怕以后这个类改变后你需要回来改代码，而此时依赖这个类的地方已经到处都是
2. 这个类的对象构建过程非常复杂，你不愿意将这样复杂的构建过程一遍又一遍的写在需要用到此对象的地方
3. 这个类的对象在构建过程中依赖了很多其他的类，而你无法在调用的地方提供

## [单例模式](https://blog.csdn.net/ShuSheng0007/article/details/117266347)

1. 静态常量

   在类加载的时候就创建了实例，属于饿汉模式。其是线程安全的，这一点由JVM保证，但是有一个确定，可以通过反射创建新的实例

2. 单null检查

   线程不安全，可以将获取实例的方法进行同步，但是性能大大的降低了，因为获取实例，需要排队

3. 双重null检查

   > 因为cpu的IO读写速率比cpu从存储设备中读取的速度慢很多，所以引入了高速缓存（缓解了CPU与内存速度差的问题），但是也引入了缓存一致性的问题，因为每个CPU都有自己的高速缓存，而他们又共用同一主内存，所以每个CPU的高速缓存数据不一致的时候，同步回主内存时使用谁的值，就不得而知了，所以这是需要一套每个CPU在访问缓存时候都遵循的一套协议
   >
   > 此外，为了执行效率，CPU还会对代码乱序执行，这对应到Java虚拟机上为指令重排
   >
   > Volatile
   >
   > 1. 可见性
   >
   >    当一个变量被声明Volatile后，A线程修改变量时，B线程中的变量也会立即被修改
   >
   > 2. 禁止指令重排优化

   使用double-check方式一定要加上volatile关键字，否则由于指令重拍会导致单例失败

   第一个check为了提高访问性能。因为一旦实例被创建，所有的check方法永远为假。其实可以把第一层check去掉，只是访问性能会降低，那么就变成与直接同步一样的方法了

   第二个check是为了线程安全，确保多线程环境下只生成一个实例、

   第一个check可以被多个线程进入，第二个check只能排队进入

4. 静态内部类

   既是线程安全的，也是懒汉式的，哪个实例只有在你首次访问时候才会生成，完全可以使用这种方式替代double-check方式

   ```java
   public class Singleton5 {
       private Singleton5() {
           
       }
       
       private static class SingletonInstance {
           private final static Singleton5 INSTANCE = new Singleton5();
       }
       
       public static Singleton5 getInstance() {
           return SingletonInstance.INSTANCE;
       }
   }
   ```

5. **枚举**

   以上四种方式都有一个共同的问题，即通过反射的方式可以创建多个实例。如果你的类实现了序列化，那还要防止序列化生成多个实例的问题

   ```java
   public enum Singleton6 {
       INSTANCE;
   }
   ```

## [原型模式](https://blog.csdn.net/ShuSheng0007/article/details/116463979)

* 当一个对象的构建代价过高时。例如某个对象里面的数据需要访问数据库才能拿到，而我们却需要多次构建这样的对象时
* 当构建的多个对象，均需要某种原始状态时，就可以先构建一个拥有此状态的原型对象，其他对象基于原型对象进行修改

> 深克隆VS浅克隆
>
> 深克隆——引用值会重新声明，与被克隆对象无关
>
> 浅克隆——引用值与被克隆对象指向同一地址，原本的对象改变，克隆对象也会改变

## [构建者模式](https://blog.csdn.net/ShuSheng0007/article/details/86619675)

当一个类的构造函数参数个数超过4个，而且这些参数有些时可选的参数，就可以考虑使用建造者模式

通过链式调用，一步一步的把对象构建出来

## [抽象工厂模式](https://blog.csdn.net/ShuSheng0007/article/details/86644481)

如果你的业务中出现了要依据不同的产品家族来生产其旗下的一系列产品的时候，抽象工厂模式就可以被使用了

## [桥接模式](https://blog.csdn.net/ShuSheng0007/article/details/88370067)

1. 如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系
2. 抽象部分和实现部分可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和要给实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合
3. 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展
4. 对于那些不希望使用继承或因为多层继承导致类的个数急剧增加的系统，桥接模式尤为适用

## [策略模式](https://blog.csdn.net/ShuSheng0007/article/details/88085445)

当写代码的时候发现一个操作有好多种实现方式，而你需要根据不同情况使用if-else等分支结构来确定使用那种实现方式的时候，就可以使用这个模式

## [组合模式](https://blog.csdn.net/ShuSheng0007/article/details/116378002)

当程序结构右类似树一样的层级关系时

当你要以统一的方式操作单个对象和由这些对象组成的组合对象时

## [装饰者模式](https://blog.csdn.net/ShuSheng0007/article/details/88780036)

需要在运行时动态的给一个对象增加额外的职责时

需要给一个现有的类增加职责，但又不想通过继承的方式来实现的时候（应该优先使用组合而非继承），或者通过继承的方式不实现的时候（可能由于排列组合产生类爆炸的问题）

## [访问者模式](https://blog.csdn.net/ShuSheng0007/article/details/117839084)

当有个类，里面包含了各种类型的元素，这个类结构比较稳定，不会经常增删不同类型的元素。而需要经常给这些元素添加新的操作的时候，可以使用这个设计模式

## [责任链模式](https://blog.csdn.net/ShuSheng0007/article/details/116138433)

一个请求需要被多个对象中的某一个处理，但是到底是哪个对象必须在运行时根据条件决定

## [外观模式](https://blog.csdn.net/ShuSheng0007/article/details/116428733)

当程序有很多个模块，或者说子系统。你希望给用户提供一个统一的操作系统界面类，而不是让用户分别与这些模块打交道交互。

一种设计：给用户提供一套面板方用来完成一般性的功能，如果面板提供的方法不能满足用户需求，用户还可以直接适用具体模板的功能来达到自己的目的

另一种设计：用户完全看不到各子模块，所有操作必须通过面板来完成，如果面板没有提供响应的功能，没有办法调整

## 中介模式（等待）

## [观察者模式](https://blog.csdn.net/ShuSheng0007/article/details/125122173?spm=1001.2014.3001.5501)

当业务复合**订阅-发布**这种场景时考虑这个模式

## [备忘录模式](https://blog.csdn.net/ShuSheng0007/article/details/117430604)

当开发一个功能，这个功能需要存档的时候，就可以使用它

## [状态模式](https://blog.csdn.net/ShuSheng0007/article/details/116375477)

当发现代码中存在一个很长的if-else列表，而这些分支都是因为不同状态下执行的操作不一样时考虑适用这个模式

## [享元模式](https://blog.csdn.net/ShuSheng0007/article/details/116424138)

当你的程序中存在大量相似的对象，每个对象之间只是根据不同的适用场景有些许变化时，类似于池的概念

## [代理模式](https://blog.csdn.net/ShuSheng0007/article/details/80864854)

* 远程代理：为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作一直性能更好的计算机上，提高系统的整体运行效率
* 虚拟代理：通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销
* 缓冲代理：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间
* 保护代理：可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限
* 智能引用：要为一个对象的访问（引用）提供一些额外的操作时可以使用

## [命令模式](https://blog.csdn.net/ShuSheng0007/article/details/116115743)

当需要将各种执行的动作抽象出来，使用时通过不同的参数来决定执行哪个对象

当某个或者某些操作需要支持撤销的情况

当要对操作过程记录日志，以便后期通过日志将操作过程重新做一遍时

当某个操作需要支持事务操作时

## 解释器模式（等待）



## [设计模式六大原则](https://www.cnblogs.com/huansky/p/13700861.html)

* 单一责任原则（类和方法、接口）

  将功能细分，一个类对应一个功能，不能让一个类负责多个功能

* 开闭原则（扩展开放，修改关闭）

  通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类

* 里氏替换原则（基类和子类之间的关系）

  子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法

  子类中可以增加自己的特有方法

  当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松

  当子类的方法实现父类的方法时（重写/重载或者实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类的方法更加严格或相等

* 依赖倒置原则（依赖抽象接口，而不是具体对象）

  每个类尽量提供接口或抽象类，或者两者都具备

  变量的声明类型尽量是接口或者抽象类

  任何类都不应该从具体类派生

  使用继承时尽量遵循里氏替换原则

* 接口隔离原则（接口按照功能细分）

  接口尽量小，但是要有限度，一个接口只服务于一个子模块或者业务逻辑

  为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法

  了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑

  提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情

* 迪米特法则（类与类之间的亲疏关系）

  在类的划分下，应该创建弱耦合的类。类与类之间耦合越弱，就越有利于实现可复用的目标

  在类的结构设计中，尽量降低类成员的访问权限

  在类的设计上，优先考虑将一个类设置成不变类

  在对其他类的引用上，将引用其他对象的次数降到最低

  不暴露类的属性成员，而应该提供响应的访问器（set和get方法）

  谨慎使用序列化功能
