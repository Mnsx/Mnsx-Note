# 代码随想录

[视频地址](https://www.bilibili.com/video/BV12A4y1Z7LP/?spm_id_from=pageDriver&vd_source=ef4cb053cb06864b58691c8387a45008)

## 数组

### 二分查找法

[题目地址](https://leetcode.cn/problems/binary-search/)

* 左闭右闭

  > left <= right
  > left = mid + 1
  > right = mid - 1

```java
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;

        while (l <= r) {
            int mid = l + ((r - l) >> 1);

            if (nums[mid] > target) {
                r = mid - 1;
            } else if (nums[mid] < target) {
                l = mid + 1;
            } else {
                return mid;
            }
        }
        
        return -1;
    }
}
```

* 左闭右开

  > left < right
  >
  > left = mid + 1
  >
  > right = mid

```java
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;

        while (l < r) {
            int mid = l + ((r - l) >> 1);

            if (nums[mid] > target) {
                r = mid;
            } else if (nums[mid] < target) {
                l = mid + 1;
            } else {
                return mid;
            }
        }

        return -1;
    }
}
```

### 移除元素

[题目地址](https://leetcode.cn/problems/remove-element/)

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int fast = 0, slow = 0;

        for (; fast < nums.length; ++fast) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
        }

        return slow;
    }
}
```

### 有序数组的平方

[题目地址](https://leetcode.cn/problems/squares-of-a-sorted-array/)

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int n = nums.length, k = n - 1;
        int[] result = new int[n];
        
        int left = 0, right = n - 1;
        while (left <= right) {
            int l = (int)Math.pow(nums[left], 2);
            int r = (int)Math.pow(nums[right], 2);
            if (l > r) {
                result[k--] = l;
                left++;
            } else {
                result[k--] = r;
                right--;
            }
        }

        return result;
    }
}
```

### 长度最小的子数组

[题目地址](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int sum = 0, result = Integer.MAX_VALUE, i = 0;
        
        for (int j = 0; j < nums.length; ++j) {
            sum += nums[j];
            while (sum >= target) {
                result = Math.min(result, j - i + 1);
                sum -= nums[i++];
            }
        }

        return result != Integer.MAX_VALUE ? result : 0;
    }
}
```

### 螺旋矩阵II

[题目地址](https://leetcode.cn/problems/spiral-matrix-ii/)

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int start = 0, count = 1, offset = 1, i = 0, j = 0, num = n / 2;
        int[][] result = new int[n][n];

        while (num-- > 0) {
            for (j = start, i = start; j < n - offset; ++j) {
                result[i][j] = count++;
            }

            for (; i < n - offset; ++i) {
                result[i][j] = count++;
            }

            for (; j > start; --j) {
                result[i][j] = count++;
            }

            for (; i > start; --i) {
                result[i][j] = count++;
            }

            start++;
            offset++;
        }

        if (n % 2 != 0) {
            result[start][start] = count;
        }

        return result;
    }
}
```

## 链表

### 移除链表元素

[题目地址](https://leetcode.cn/problems/remove-linked-list-elements/)

* 正常方法

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        while (head != null && head.val == val) {
            head = head.next;
        }

        ListNode cur = head;
        while (cur != null && cur.next != null) {
            if (cur.next.val == val) {
                cur.next = cur.next.next;
            } else {
                cur = cur.next;
            }
        }

        return head;
    }
}
```

* 创建虚拟头节点

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode aHead = new ListNode();
        aHead.next = head;

        ListNode cur = aHead;
        while (cur != null && cur.next != null) {
            if (cur.next.val == val) {
                cur.next = cur.next.next;
            } else {
                cur = cur.next;
            }
        }

        return aHead.next;
    }
}
```

### 设计链表

[题目地址](https://leetcode.cn/problems/design-linked-list/)

```java
class MyLinkedList {
    ListNode head;
    int size = 0;

    public MyLinkedList() {
        head = new ListNode(); 
    }
    
    public int get(int index) {
        if (index >= size) {
            return -1;
        }
        
        ListNode cur = head;
        while (index-- != 0) {
            cur = cur.next;
        }
        return cur.next.val;
    }
    
    public void addAtHead(int val) {
        ListNode newList = new ListNode(val);
        newList.next = head.next;
        head.next = newList;
        size++;
    }
    
    public void addAtTail(int val) {
        ListNode cur = head;
        while (cur.next != null) {
            cur = cur.next;
        }
        ListNode newList = new ListNode(val);
        cur.next = newList;
        size++;
    }
    
    public void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        
        ListNode cur = head;
        while (index-- != 0) {
            cur = cur.next;
        }
        ListNode newList = new ListNode(val);
        newList.next = cur.next;
        cur.next = newList;
        size++;
    }
    
    public void deleteAtIndex(int index) {
        if (size == 0 || index >= size) {
            return;
        }

        ListNode cur = head;
        while (index-- != 0) {
            cur = cur.next;
        }
        cur.next = cur.next.next;
        size--;
    }
}
```

### 反转联表

[题目地址](https://leetcode.cn/problems/reverse-linked-list/)

* 双指针

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur = head, pre = null;

        while (cur != null) {
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }

        return pre;
    }
}
```

* 递归法

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        return reverse(head, null);
    }

    public ListNode reverse(ListNode cur, ListNode pre) {
        if (cur == null) {
            return pre;
        }

        ListNode temp = cur.next;
        cur.next = pre;

        return reverse(temp, cur);
    }
}
```

### 两两交换联表中的节点

[题目地址](https://leetcode.cn/problems/swap-nodes-in-pairs/)

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode aHead = new ListNode();
        aHead.next = head;
        ListNode cur = aHead;

        while (cur.next != null && cur.next.next != null) {
            ListNode t1 = cur.next;
            ListNode t2 = cur.next.next.next;

            cur.next = cur.next.next;
            cur.next.next = t1;
            t1.next = t2;

            cur = cur.next.next;
        }

        return aHead.next;
    }
}
```

### 删除链表中的倒数第N个结点

[题目地址](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```java 
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode aHead = new ListNode();
        aHead.next = head;
        ListNode fast = aHead, slow = aHead;
        n++;

        while (n-- != 0 && fast != null) {
            fast = fast.next;
        }

        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }

        slow.next = slow.next.next;

        return aHead.next;
    }
}
```

### 环形链表II

[题目地址](https://leetcode.cn/problems/linked-list-cycle-ii/)

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
       ListNode fast = head, slow = head;

       while (fast != null && fast.next != null) {
           fast = fast.next.next;
           slow = slow.next;
           if (fast == slow) {
               ListNode index1 = fast;
               ListNode index2 = head;
               while (index1 != index2) {
                   index1 = index1.next;
                   index2 = index2.next;
               }
               return index1;
           }
       } 
       return null;
    }
}
```

## 哈希表

### 有效的字母异位词

[题目地址](https://leetcode.cn/problems/valid-anagram/)

* Map

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        Map<Character, Integer> map = new HashMap<>();
        for (char ch : s.toCharArray()) {
            map.put(ch, map.getOrDefault(ch, 0) + 1);
        }
        for (char ch : t.toCharArray()) {
            map.put(ch, map.getOrDefault(ch, 0) - 1);
        }
        for (Map.Entry<Character, Integer> entry : map.entrySet()) {
            if (entry.getValue() != 0) {
                return false;
            }
        }
        return true;
    }
}
```

* 数组

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] map = new int[26];
        for (char ch : s.toCharArray()) {
            map[ch - 'a']++;
        }
        for (char ch : t.toCharArray()) {
            map[ch - 'a']--;
        }
        for (int i : map) {
            if (i != 0) {
                return false;
            }
        }
        return true;
    }
}
```

### 两个数组的交集

[题目地址](https://leetcode.cn/problems/intersection-of-two-arrays/)

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> list = new HashSet<>();
        Set<Integer> set = new HashSet<>();
        for (int num : nums1) {
            list.add(num);
        }

        for (int num : nums2) {
            if (list.contains(num)) {
                set.add(num);
            }
        }

        int[] result = new int[set.size()];
        int index = 0;
        for (Integer i : set) {
            result[index++] = i;
        }

        return result;
    }
}
```

### 两数之和

[题目地址](https://leetcode.cn/problems/two-sum/)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; ++i) {
            Integer result = map.getOrDefault(target - nums[i], -1);
            if (result != -1) {
                return new int[]{i, result};
            }
            map.put(nums[i], i);
        }
        return null;
    }
}
```

### 四数之和II

[题目地址](https://leetcode.cn/problems/4sum-ii/)

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        Map<Integer, Integer> map = new HashMap<>();
        int count = 0;

        for (int num1 : nums1) {
            for (int num2 : nums2) {
                map.put(num1 + num2, map.getOrDefault(num1 + num2, 0) + 1);
            }
        }

        for (int num1 : nums3) {
            for (int num2 : nums4) {
                int target = 0 - num2 - num1;
                // 方法一
                count += map.getOrDefault(target, 0);
                
                // 方法二
                // if (map.containsKey(target)) {
                //     count += map.get(target);
                // }
            }
        }

        return count;
    }
}
```

### 三数之和

[题目地址](https://leetcode.cn/problems/3sum/)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();

        Arrays.sort(nums);

        for (int i = 0; i < nums.length; ++i) {
            if (nums[i] > 0) {
                break;
            }

            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            int left = i + 1;
            int right = nums.length - 1;
            while (left < right) {
                if (nums[i] + nums[left] + nums[right] > 0) {
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[left]);
                    list.add(nums[right]);
                    result.add(list);

                    while (right > left && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    while (right > left && nums[left] == nums[left + 1]) {
                        left++;
                    }

                    left++;
                    right--;
                }
            }
        }

        return result;
    }
}
```

### 四数之和

[题目地址](https://leetcode.cn/problems/4sum/submissions/)

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);

        for (int k = 0; k < nums.length; ++k) {
            if (nums[k] > target && nums[k] > 0 && target > 0) {
                break;
            }
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }

            for (int i = k + 1; i < nums.length; ++i) {
                if (nums[i] + nums[k] > target && nums[i] + nums[k] > 0 && target > 0) {
                    break;
                }
                if (i > k + 1 && nums[i] == nums[i - 1]) {
                    continue;
                }
                int left = i + 1;
                int right = nums.length - 1;
                while (left < right) {
                    if ((long)nums[i] + nums[k] + nums[left] + nums[right] > Integer.MAX_VALUE) {
                        break;
                    }
                    if (nums[i] + nums[k] + nums[left] + nums[right] > target) {
                        right--;
                    } else if (nums[i] + nums[k] + nums[left] + nums[right] < target) {
                        left++;
                    } else {
                        List<Integer> list = new ArrayList<>();
                        list.add(nums[k]);
                        list.add(nums[i]);
                        list.add(nums[left]);
                        list.add(nums[right]);
                        result.add(list);

                        while (right > left && nums[left] == nums[left + 1]) {
                            left++;
                        }
                        while (right > left && nums[right] == nums[right - 1]) {
                            right--;
                        }

                        left++;
                        right--;
                    }
                }
            }
        }
        return result;
    }
}
```

## 字符串

### 反转字符串

[题目地址](https://leetcode.cn/problems/reverse-string/submissions/)

```java
class Solution {
    public void reverseString(char[] s) {
        for (int i = 0, j = s.length -1; i < s.length / 2; ++i, --j) {
            char temp = s[i];
            s[i] = s[j];
            s[j] = temp;
        }
    }
}
```

### 反转字符串II

[题目地址](https://leetcode.cn/problems/reverse-string-ii/submissions/)

```java
class Solution {
    public String reverseStr(String s, int k) {
        for (int i = 0; i < s.length(); i += 2 * k) {
            if (i + k < s.length()) {
                s = reverse(s.toCharArray(), i, i + k);
                continue;
            }
            s = reverse(s.toCharArray(), i, s.length());
        }

        return s;
    }

    public String reverse(char[] s, int l, int r) {
        for (int i = l, j = r - 1; i < ((r + l) >> 1); ++i, --j) {
            char temp = s[i];
            s[i] = s[j];
            s[j] = temp;
        }
        return String.valueOf(s);
    }
}
```

### 反转字符串里的单词

[题目地址](https://leetcode.cn/problems/reverse-words-in-a-string/)

```java
class Solution {
    public String reverseWords(String s) {
        char[] chars = reverse(s);
        System.out.println(Arrays.toString(chars));
        StringBuffer sb = new StringBuffer();
        for (int fast = 0; fast < chars.length; ++fast) {
            if (chars[fast] != ' ') {
                if (!sb.isEmpty()) {
                    sb.append(' ');
                }

                while (fast < chars.length && chars[fast] != ' ') {
                    sb.append(chars[fast]);
                    fast++;
                }
            }
        }

        String res = sb.toString();
        String[] ss = res.split(" ");
        res = "";
        for (String sss : ss) {
            res += String.valueOf(reverse(sss));
            res += " ";
        }

        return res.trim();
    }

    public char[] reverse(String s) {
        char[] ch = s.toCharArray();
        for (int i = 0, j = s.length() - 1; i < s.length() / 2; ++i, --j) {
            char temp = ch[i];
            ch[i] = ch[j];
            ch[j] = temp;
        }
        return ch;
    }
}
```

### 找出字符串中第一个匹配项的下标

[题目地址](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

```java
class Solution {
    public int strStr(String haystack, String needle) {
        int[] next = getNext(needle);

        if (needle.length() > haystack.length()) {
            return -1;
        }

        int j = 0;
        int res = 0;
        boolean flag = true;
        for (int i = 0; i < haystack.length() && j < needle.length(); ++i) {
            if (haystack.charAt(i) == needle.charAt(j)) {
                if (flag) {
                    res = i - j;
                    flag = false;
                }
                j++;
            } else {
                if (j == 0) {
                    continue;
                }

                j = next[j - 1];
                i -= 1;
                flag = true;
            }
        }
        if (j == needle.length()) {
            return res;
        } 
        return -1;
    }

    public int[] getNext(String str) {
        int i = 1, j = 0;
        int[] next = new int[str.length()];
        next[0] = 0;
        for (; i < str.length(); ++i) {
            while (j > 0 && str.charAt(i) != str.charAt(j)) {
                j = next[j - 1];
            }

            if (str.charAt(i) == str.charAt(j)) {
                j++;
            }
            next[i] = j;
        }
        return next;
    }
}
```

### 重复的子字符串

[题目地址](https://www.bilibili.com/video/BV1cg41127fw/?spm_id_from=333.788&vd_source=ef4cb053cb06864b58691c8387a45008)

* 匹配字符串

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        return (s + s).indexOf(s, 1) != s.length();
    }
}
```

* KMP

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        return kmp(s + s, s);
    }

    public boolean kmp(String query, String pattern) {
        int n = query.length();
        int m = pattern.length();
        int[] fail = new int[m];
        Arrays.fill(fail, -1);
        for (int i = 1; i < m; ++i) {
            int j = fail[i - 1];
            while (j != -1 && pattern.charAt(j + 1) != pattern.charAt(i)) {
                j = fail[j];
            }
            if (pattern.charAt(j + 1) == pattern.charAt(i)) {
                fail[i] = j + 1;
            }
        }
        int match = -1;
        for (int i = 1; i < n - 1; ++i) {
            while (match != -1 && pattern.charAt(match + 1) != query.charAt(i)) {
                match = fail[match];
            }
            if (pattern.charAt(match + 1) == query.charAt(i)) {
                ++match;
                if (match == m - 1) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

## 栈和队列

### 用栈实现队列

[题目地址](https://www.bilibili.com/video/BV1nY4y1w7VC/?spm_id_from=333.788&vd_source=ef4cb053cb06864b58691c8387a45008)

```java
class MyQueue {
    Deque<Integer> queueIn = null;
    Deque<Integer> queueOut = null;

    public MyQueue() {
        queueIn = new LinkedList<>();
        queueOut = new LinkedList<>();
    }
    
    public void push(int x) {
        queueIn.push(x);
    }
    
    public int pop() {
        if (queueOut.isEmpty()) {
            while (!queueIn.isEmpty()) {
                queueOut.push(queueIn.pop());
            }
        }
        return queueOut.pop();
    }
    
    public int peek() {
        int result = pop();
        queueOut.push(result);
        return result;
    }
    
    public boolean empty() {
        return queueIn.isEmpty() && queueOut.isEmpty();
    }
}
```

### 用队列实现栈

[题目地址](https://www.bilibili.com/video/BV1Fd4y1K7sm/?spm_id_from=pageDriver&vd_source=ef4cb053cb06864b58691c8387a45008)

```java
class MyStack {
    Deque<Integer> stack = null;

    public MyStack() {
        stack = new LinkedList<>();
    }
    
    public void push(int x) {
        stack.offer(x);
    }
    
    public int pop() {
        int size = stack.size();
        while (--size != 0) {
            int temp = stack.poll();
            stack.offer(temp);
        }
        return stack.poll();
    }
    
    public int top() {
        int result = pop();
        stack.offer(result);
        return result;
    }
    
    public boolean empty() {
        return stack.isEmpty();
    }
}
```

### 有效的括号

[题目地址](https://leetcode.cn/problems/valid-parentheses/submissions/)

```java
class Solution {
    public boolean isValid(String s) {
        Deque<Character> stack = new LinkedList<>();
        for (char ch : s.toCharArray()) {
            if (ch == '(') {
                stack.push(')');
            } else if (ch == '{') {
                stack.push('}');
            } else if (ch == '[') {
                stack.push(']');
            } else if (stack.isEmpty() || ch != stack.element()) {
                return false;
            } else {
                stack.pop();
            }
        }

        return stack.isEmpty();
    }
}
```

### 删除字符串中所有相邻重复项

[题目地址](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

```java
class Solution {
    public String removeDuplicates(String s) {
        Deque<Character> stack = new LinkedList<>();
        for (char ch : s.toCharArray()) {
            if (stack.isEmpty() || ch != stack.element()) {
                stack.push(ch);
            } else {
                stack.pop();
            }
        }
        StringBuffer sb = new StringBuffer();
        while (!stack.isEmpty()) {
            sb.append(stack.pop());
        }
        return sb.reverse().toString();
    }
}
```

### 逆波兰表达式求值

[题目地址](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack = new LinkedList<Integer>();
        int n = tokens.length;
        for (int i = 0; i < n; i++) {
            String token = tokens[i];
            if (isNumber(token)) {
                stack.push(Integer.parseInt(token));
            } else {
                int num2 = stack.pop();
                int num1 = stack.pop();
                switch (token) {
                    case "+":
                        stack.push(num1 + num2);
                        break;
                    case "-":
                        stack.push(num1 - num2);
                        break;
                    case "*":
                        stack.push(num1 * num2);
                        break;
                    case "/":
                        stack.push(num1 / num2);
                        break;
                    default:
                }
            }
        }
        return stack.pop();
    }

    public boolean isNumber(String token) {
        return !("+".equals(token) || "-".equals(token) || "*".equals(token) || "/".equals(token));
    }
}
```

### 滑动窗口最大值

[题目地址](https://leetcode.cn/problems/sliding-window-maximum/)

```java
class Solution {
    public Deque<Integer> queue = new LinkedList<>();

    public void poll(int val) {
        if (!queue.isEmpty() && val == queue.peekLast()) {
            queue.pollLast(); 
        }
    }

    public void offer(int val) {
        while (!queue.isEmpty() && val > queue.peek()) {
            queue.pollFirst();
        }
        queue.offerFirst(val);
    }

    public int getMax() {
        return queue.peekLast();
    }

    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] res = new int[nums.length - k + 1];
        int i = 0;
        for (int j = 0; j < nums.length; ++j) {
            offer(nums[j]);
            if (j >= k - 1) {
                res[i] = getMax();
                poll(nums[i]);
                i++;
            }
        }
        return res;
    }
}
```

### 求前k个高频元素

[题目地址](https://leetcode.cn/problems/top-k-frequent-elements/)

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        Queue<Integer> pq = new PriorityQueue<>((k1, k2) -> {
            return map.get(k1) - map.get(k2);
        });
        for (Integer key : map.keySet()) {
            pq.add(key);
            if (pq.size() > k) {
                pq.poll();
            }
        }
        int[] result = new int[k];
        for (int i = k - 1; i >= 0; --i) {
            result[i] = pq.poll(); 
        }
        return result;
    }
}
```

## 二叉树

### 前序遍历

[题目地址](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

* 递归

```java
class Solution {
    List<Integer> res = new ArrayList<>();

    public List<Integer> preorderTraversal(TreeNode root) {
        def(root, res);
        return res;
    }

    public void def(TreeNode node, List<Integer> list) {
        if (node == null) {
            return;
        }

        list.add(node.val);
        def(node.left, list);
        def(node.right, list);
    }
}
```

* 非递归

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        Deque<TreeNode> stack = new LinkedList<>();
        List<Integer> list = new ArrayList<>();

        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if (node != null) {
                list.add(node.val);
            } else {
                continue;
            }
            stack.push(node.right);
            stack.push(node.left);
        }

        return list;
    }
}
```

### 中序遍历

[题目地址](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

* 递归

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>(); 
        dfs(root, res);
        return res;
    }

    public void dfs(TreeNode root, List<Integer> res) {
        if (root == null) {
            return ;
        }

        dfs(root.left, res);
        res.add(root.val);
        dfs(root.right, res);
    }
}
```

* 非递归

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            } else {
                cur = stack.pop();
                list.add(cur.val);
                cur = cur.right;
            }
        }
        return list;
    }
}
```

### 后序遍历

[题目地址](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

* 递归

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>(); 
        dfs(root, res);
        return res;
    }

    public void dfs(TreeNode root, List<Integer> res) {
        if (root == null) {
            return ;
        }

        dfs(root.left, res);
        dfs(root.right, res);
        res.add(root.val);
    }
}
```

* 非递归

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if (node != null) {
                list.add(node.val);
            } else {
                continue;
            }
            stack.push(node.left);
            stack.push(node.right);
        }
        Collections.reverse(list);
        return list;
    }
}
```

### 层序遍历

[题目地址](https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < size; ++i) {
                TreeNode node = queue.poll();
                if (node == null) {
                    continue;
                }
                list.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                } 
                if (node.right != null) {
                    queue.offer(node.right);
                }
                if (i == size - 1) {
                    res.add(list);
                }
            }
        }
        return res;
    }
}
```

### 反转二叉树

[题目地址](https://leetcode.cn/problems/invert-binary-tree/submissions/)

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```

### 对称二叉树

[题目地址](https://leetcode.cn/problems/symmetric-tree/)

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return doFun(root.left, root.right);
    }

    public boolean doFun(TreeNode left, TreeNode right) {
        if (left != null && right == null) {
            return false;
        }
        if (left == null && right != null) {
            return false;
        }
        if (left == null && right == null) {
            return true;
        }
        if (left.val != right.val) {
            return false;
        }
        boolean out = doFun(left.left, right.right);
        boolean in = doFun(left.right, right.left);
        return out && in;
    }
}
```

### 二叉树的最大深度

[题目地址](https://leetcode.cn/problems/maximum-depth-of-binary-tree/submissions/)

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}
```

### 二叉树的最小深度

[题目地址](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

```java
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        if (root.left == null && root.right != null) {
            return 1 + minDepth(root.right);
        }
        if (root.left != null && root.right == null) {
            return 1 + minDepth(root.left);
        }
        return 1 + Math.min(minDepth(root.left), minDepth(root.right));
    }
}
```

### 完全二叉树的节点个数

[题目地址](https://leetcode.cn/problems/count-complete-tree-nodes/)

* 正常二叉树方法

```java
class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) {
            return 0;
        }

        return (countNodes(root.left) + countNodes(root.right) + 1);
    }
}
```

* 完全二叉树特性

```java
class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) {
            return 0;
        }
        TreeNode left = root.left;
        TreeNode right = root.right;
        int leftCount = 0;
        int rightCount = 0;
        while (left != null) {
            left = left.left;
            leftCount++;
        }
        while (right != null) {
            right = right.right;
            rightCount++;
        }
        if (leftCount == rightCount) {
            return (2 << leftCount) - 1;
        }
        return (countNodes(root.left) + countNodes(root.right) + 1);
    }
}
```

### 平衡二叉树

[题目地址]()

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }

    public int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = getHeight(root.left);
        if (leftHeight == -1) {
            return -1;
        }
        int rightHeight = getHeight(root.right);
        if (rightHeight == -1) {
            return -1;
        }
        if (Math.abs(rightHeight - leftHeight) > 1) {
            return -1;
        } else {
            return 1 + Math.max(rightHeight, leftHeight);
        }
    }
}
```

### 二叉树的所有路径

[题目地址](https://leetcode.cn/problems/binary-tree-paths/)

```java
class Solution {
    List<String> list = new ArrayList<>();

    public List<String> binaryTreePaths(TreeNode root) {
        if (root == null) {
            return list;
        }

        doFun(root, "");
        return list;
    }

    public void doFun(TreeNode root, String target) {
        target += (root.val + "->");
        if (root.left == null && root.right == null) {
            list.add(target.substring(0, target.length() - 2));
            return ;
        }

        if (root.left != null) {
            doFun(root.left, target);
        }
        if (root.right != null) {
            doFun(root.right, target);
        }
    }
}
```

### 左子树之和

[题目地址](https://leetcode.cn/problems/sum-of-left-leaves/)

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) {
            return 0;
        }
        if (root.left == null && root.right == null) {
            return 0;
        }

        int leftNum = sumOfLeftLeaves(root.left);
        if (root.left != null && root.left.left == null && root.left.right == null) {
            leftNum = root.left.val;
        }

        int rightNum = sumOfLeftLeaves(root.right);

        int sum = leftNum + rightNum;

        return sum;
    }
}
```

### 找树左下角的值

[题目地址](https://leetcode.cn/problems/find-bottom-left-tree-value/)

```java
class Solution {
    int maxDepth = Integer.MIN_VALUE;
    int result = 0;
    public int findBottomLeftValue(TreeNode root) {
        return doFun(root, 0);
    }

    public int doFun(TreeNode root, int depth) {
        if (root.left == null && root.right == null) {
            if (depth > maxDepth) {
                maxDepth = depth;
                result = root.val;
            }
        }

        if (root.left != null) {
            doFun(root.left, depth+1);
        }
        if (root.right != null) {
            doFun(root.right, depth+1);
        }

        return result;
    }
}
```

### 路径总和

[题目地址](https://leetcode.cn/problems/path-sum/)

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return sum == root.val;
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```

### 从中序与后序遍历序列构造二叉树

[题目地址](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```java
class Solution {
    public TreeNode buildTree(int[] in, int[] post) {
        // 后续数组如果为0，那么就是空节点返回null
        if (post.length == 0) {
            return null;
        }

        // 后续最后一个元素为根节点
        TreeNode root = new TreeNode(post[post.length - 1]);

        // 如果后续数组数量为1，那么只有一个根节点
        if (post.length == 1) {
            return root;
        }

        // 遍历中序数组的切割点
        int i = 0;
        for (i = 0; i < in.length; ++i) {
            if (in[i] == root.val) {
                break;
            }
        }

        int[] lin = new int[i];
        int[] rin = new int[in.length - lin.length - 1];
        // 切割中序数组
        for (int j = 0; j < i; ++j) {
            lin[j] = in[j];
        }

        for (int j = i + 1, k = 0; j < in.length; ++j, ++k) {
            rin[k] = in[j];
        }

        int[] lpost = new int[lin.length];
        int[] rpost = new int[rin.length];
        // 根据中序数组切割后续数组
        for (int j = 0; j < lin.length; ++j) {
            lpost[j] = post[j];
        }

        for (int j = lin.length, k = 0; k < rin.length; ++j, ++k) {
            rpost[k] = post[j];
        }

        root.left = buildTree(lin, lpost);
        root.right = buildTree(rin, rpost);

        return root;
    }
}
```

### 最大二叉树

[题目地址](https://leetcode.cn/problems/maximum-binary-tree/)

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return doFun(0, nums.length, nums);
    }

    public TreeNode doFun(int left, int right, int[] nums) {
        if (left >= right) {
            return null;
        }
        if (right - left + 1 == 1) {
            return new TreeNode(nums[0]);
        }

        int max = 0;
        int index = left;
        for (int i = left; i < right; ++i) {
            if (nums[i] > max) {
                max = nums[i];
                index = i;
            }
        }
        TreeNode root = new TreeNode(max);

        root.left = doFun(left, index, nums);

        root.right = doFun(index + 1, right, nums);

        return root;
    }
}
```

### 合并二叉树

[题目地址](https://leetcode.cn/problems/merge-two-binary-trees/)

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) {
            return root2;
        }
        if (root2 == null) {
            return root1;
        }

        root1.val += root2.val;

        root1.left = mergeTrees(root1.left, root2.left);
        root1.right = mergeTrees(root1.right, root2.right);

        return root1;
    }
}
```

### 二叉搜索树的搜索

[题目地址](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

* 递归法

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null || root.val == val) {
            return root;
        }
        
        TreeNode node = new TreeNode();

        if (root.val > val) {
            node = searchBST(root.left, val);
        } 
        if (root.val < val) {
            node = searchBST(root.right, val);
        }

        return node;
    }
}
```

* 迭代法

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        while (root != null) {
            if (root.val > val) {
                root = root.left;
            } else if (root.val < val) {
                root = root.right;
            } else {
                return root;
            }
        }
        return null;
    }
}
```

### 验证二叉搜索树

[题目地址]()

```java
class Solution {
    TreeNode pre = null;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }

        boolean left = isValidBST(root.left);

        if (pre != null && pre.val >= root.val) {
            return false;
        }
        pre = root;

        boolean right = isValidBST(root.right);

        return left && right;
    }
}
```

### 二叉搜索树的最小绝对差

[题目地址](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

```java
class Solution {
    int result = Integer.MAX_VALUE;
    TreeNode pre = null;

    public int getMinimumDifference(TreeNode root) {
        doFun(root);
        return result;
    }
    
    public void doFun(TreeNode root) {
        if (root == null) {
            return;
        }

        doFun(root.left);

        if (pre != null) {
            result = Math.min(result, root.val - pre.val);
        }
        pre = root;

        doFun(root.right);
    }
}	
```

### 二叉搜索树中的众数

[题目地址](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

```java
class Solution {
    TreeNode pre = null;
    int count = 0;
    int max = 0;
    List<Integer> list = new ArrayList<>();
    public int[] findMode(TreeNode root) {
        doFun(root);

        return list.stream().mapToInt(i -> i).toArray();
    }

    public void doFun(TreeNode root) {
        if (root == null) {
            return;
        }
        doFun(root.left);
        if (pre == null) {
            count = 1;
        } else if (root.val == pre.val) {
            count++;
        } else {
            count = 1;
        }
        pre = root;
        if (count == max) {
            list.add(root.val);
        }
        if (count > max) {
            list = new ArrayList<>();
            max = count;
            list.add(root.val);
        }
        doFun(root.right);
    }
}
```

## 回溯算法

### 组合

[题目地址](https://leetcode.cn/problems/combinations/)

* 常规写法

```java
class Solution {
    List<List<Integer>> pathList = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> combine(int n, int k) {
        doFun(n, k, 1);
        return pathList;
    }

    public void doFun(int n, int k, int index) {
        if (path.size() == k) {
            pathList.add(new ArrayList<>(path));
            return;
        }

        for (int i = index; i <= n; ++i) {
            path.add(i);
            doFun(n, k, i + 1); 
            path.remove(path.size() - 1);
        }
    }
}
```

* 剪枝操作

```java
class Solution {
    List<Integer> list = new ArrayList<>();
    List<List<Integer>> lists = new ArrayList<>();

    public List<List<Integer>> combine(int n, int k) {
        doFun(n, k, 1);
        return lists;
    }

    public void doFun(int n, int k, int index) {
        if (list.size() == k) {
            lists.add(new ArrayList<>(list));
            return;
        }

        for (int i = index; i <= n - (k - list.size()) + 1; ++i) {
            list.add(i);
            doFun(n, k, i + 1);
            list.remove(list.size() - 1);
        }
    }
}
```

### 组合总和

[题目地址](https://leetcode.cn/problems/combination-sum/)

* 常规写法

```java
class Solution {
    List<Integer> list = new ArrayList<>();
    List<List<Integer>> lists = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        doFun(candidates, target, 0);
        return lists;
    }

    public void doFun(int[] c, int t, int i) {
        if (t < 0) {
            return;
        }
        if (t == 0) {
            lists.add(new ArrayList<>(list));
            return;
        }

        for (int j = i; j < c.length; ++j) {
            list.add(c[j]);
            doFun(c, t - c[j], j);
            list.remove(list.size() - 1);
        }
    }
}
```

* 剪枝操作

```java
class Solution {
    List<Integer> list = new ArrayList<>();
    List<List<Integer>> lists = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        doFun(candidates, target, 0);
        return lists;
    }

    public void doFun(int[] c, int t, int i) {
        if (t < 0) {
            return;
        }
        if (t == 0) {
            lists.add(new ArrayList<>(list));
            return;
        }

        for (int j = i; j < c.length && t - c[j] >= 0; ++j) {
            list.add(c[j]);
            doFun(c, t - c[j], j);
            list.remove(list.size() - 1);
        }
    }
}
```

### 分割回文串

[题目地址](https://leetcode.cn/problems/palindrome-partitioning/)

```java
class Solution {
    List<String> list = new ArrayList<>();
    List<List<String>> lists = new ArrayList<>();

    public List<List<String>> partition(String s) {
        doFun(s, 0);
        return lists;
    }
    
    public void doFun(String s, int index) {
        if (index == s.length()) {
            lists.add(new ArrayList<>(list));
            return;
        }

        for (int i = index; i < s.length(); ++i) {
            if (judge(s, index, i)) {
                list.add(s.substring(index, i + 1)); 
            } else {
                continue;
            }
            doFun(s, i + 1);
            list.remove(list.size() - 1);
        }
    }

    public boolean judge(String s, int start, int end) {
        while (start <= end) {
            if (s.charAt(start++) != s.charAt(end--)) {
                return false;
            }
        }
        return true;
    }
}
```

## 动态规划

### 斐波拉契数

[题目地址](https://leetcode.cn/problems/fibonacci-number/)

```java
class Solution {
    public int fib(int n) {
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 1;
        for (int i = 3; i <= n; ++i) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

